import { router } from '@inertiajs/core';
import { cloneDeep, get, has, isEqual, set } from 'lodash-es';
import { writable } from 'svelte/store';
export default function useForm(rememberKeyOrData, maybeData) {
    const rememberKey = typeof rememberKeyOrData === 'string' ? rememberKeyOrData : null;
    const inputData = (typeof rememberKeyOrData === 'string' ? maybeData : rememberKeyOrData) ?? {};
    const data = typeof inputData === 'function' ? inputData() : inputData;
    const restored = rememberKey
        ? router.restore(rememberKey)
        : null;
    let defaults = cloneDeep(data);
    let cancelToken = null;
    let recentlySuccessfulTimeoutId = null;
    let transform = (data) => data;
    let defaultsCalledInOnSuccess = false;
    const store = writable({
        ...(restored ? restored.data : data),
        isDirty: false,
        errors: (restored ? restored.errors : {}),
        hasErrors: false,
        progress: null,
        wasSuccessful: false,
        recentlySuccessful: false,
        processing: false,
        setStore(keyOrData, maybeValue = undefined) {
            store.update((store) => {
                return typeof keyOrData === 'string' ? set(store, keyOrData, maybeValue) : Object.assign(store, keyOrData);
            });
        },
        data() {
            return Object.keys(data).reduce((carry, key) => {
                return set(carry, key, get(this, key));
            }, {});
        },
        transform(callback) {
            transform = callback;
            return this;
        },
        defaults(fieldOrFields, maybeValue) {
            defaultsCalledInOnSuccess = true;
            if (typeof fieldOrFields === 'undefined') {
                defaults = cloneDeep(this.data());
            }
            else {
                defaults =
                    typeof fieldOrFields === 'string'
                        ? set(cloneDeep(defaults), fieldOrFields, maybeValue)
                        : Object.assign(cloneDeep(defaults), fieldOrFields);
            }
            return this;
        },
        reset(...fields) {
            const clonedData = cloneDeep(defaults);
            if (fields.length === 0) {
                this.setStore(clonedData);
            }
            else {
                this.setStore(fields
                    .filter((key) => has(clonedData, key))
                    .reduce((carry, key) => {
                    return set(carry, key, get(clonedData, key));
                }, {}));
            }
            return this;
        },
        setError(fieldOrFields, maybeValue) {
            this.setStore('errors', {
                ...this.errors,
                ...(typeof fieldOrFields === 'string' ? { [fieldOrFields]: maybeValue } : fieldOrFields),
            });
            return this;
        },
        clearErrors(...fields) {
            this.setStore('errors', Object.keys(this.errors).reduce((carry, field) => ({
                ...carry,
                ...(fields.length > 0 && !fields.includes(field) ? { [field]: this.errors[field] } : {}),
            }), {}));
            return this;
        },
        resetAndClearErrors(...fields) {
            this.reset(...fields);
            this.clearErrors(...fields);
            return this;
        },
        submit(...args) {
            const objectPassed = args[0] !== null && typeof args[0] === 'object';
            const method = objectPassed ? args[0].method : args[0];
            const url = objectPassed ? args[0].url : args[1];
            const options = (objectPassed ? args[1] : args[2]) ?? {};
            defaultsCalledInOnSuccess = false;
            const data = transform(this.data());
            const _options = {
                ...options,
                onCancelToken: (token) => {
                    cancelToken = token;
                    if (options.onCancelToken) {
                        return options.onCancelToken(token);
                    }
                },
                onBefore: (visit) => {
                    this.setStore('wasSuccessful', false);
                    this.setStore('recentlySuccessful', false);
                    if (recentlySuccessfulTimeoutId) {
                        clearTimeout(recentlySuccessfulTimeoutId);
                    }
                    if (options.onBefore) {
                        return options.onBefore(visit);
                    }
                },
                onStart: (visit) => {
                    this.setStore('processing', true);
                    if (options.onStart) {
                        return options.onStart(visit);
                    }
                },
                onProgress: (event) => {
                    this.setStore('progress', event);
                    if (options.onProgress) {
                        return options.onProgress(event);
                    }
                },
                onSuccess: async (page) => {
                    this.setStore('processing', false);
                    this.setStore('progress', null);
                    this.clearErrors();
                    this.setStore('wasSuccessful', true);
                    this.setStore('recentlySuccessful', true);
                    recentlySuccessfulTimeoutId = setTimeout(() => this.setStore('recentlySuccessful', false), 2000);
                    const onSuccess = options.onSuccess ? await options.onSuccess(page) : null;
                    if (!defaultsCalledInOnSuccess) {
                        this.defaults(cloneDeep(this.data()));
                    }
                    return onSuccess;
                },
                onError: (errors) => {
                    this.setStore('processing', false);
                    this.setStore('progress', null);
                    this.clearErrors().setError(errors);
                    if (options.onError) {
                        return options.onError(errors);
                    }
                },
                onCancel: () => {
                    this.setStore('processing', false);
                    this.setStore('progress', null);
                    if (options.onCancel) {
                        return options.onCancel();
                    }
                },
                onFinish: (visit) => {
                    this.setStore('processing', false);
                    this.setStore('progress', null);
                    cancelToken = null;
                    if (options.onFinish) {
                        return options.onFinish(visit);
                    }
                },
            };
            if (method === 'delete') {
                router.delete(url, { ..._options, data });
            }
            else {
                router[method](url, data, _options);
            }
        },
        get(url, options) {
            this.submit('get', url, options);
        },
        post(url, options) {
            this.submit('post', url, options);
        },
        put(url, options) {
            this.submit('put', url, options);
        },
        patch(url, options) {
            this.submit('patch', url, options);
        },
        delete(url, options) {
            this.submit('delete', url, options);
        },
        cancel() {
            cancelToken?.cancel();
        },
    });
    store.subscribe((form) => {
        if (form.isDirty === isEqual(form.data(), defaults)) {
            form.setStore('isDirty', !form.isDirty);
        }
        const hasErrors = Object.keys(form.errors).length > 0;
        if (form.hasErrors !== hasErrors) {
            form.setStore('hasErrors', !form.hasErrors);
        }
        if (rememberKey) {
            router.remember({ data: form.data(), errors: form.errors }, rememberKey);
        }
    });
    return store;
}
