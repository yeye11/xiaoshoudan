<script>import {
  getScrollableParent,
  useInfiniteScroll
} from "@inertiajs/core";
import { onDestroy, onMount } from "svelte";
export let data = void 0;
export let buffer = 0;
export let as = "div";
export let manual = false;
export let manualAfter = 0;
export let preserveUrl = false;
export let reverse = false;
export let autoScroll = void 0;
export let startElement = null;
export let endElement = null;
export let itemsElement = null;
export let onlyNext = false;
export let onlyPrevious = false;
let itemsElementRef;
let startElementRef;
let endElementRef;
let loadingPrevious = false;
let loadingNext = false;
let requestCount = 0;
$: resolvedItemsElement = resolveHTMLElement(itemsElement, itemsElementRef);
$: scrollableParent = resolvedItemsElement ? getScrollableParent(resolvedItemsElement) : null;
$: sharedExposed = {
  loadingPrevious,
  loadingNext,
  hasPrevious: infiniteScrollInstance?.dataManager.hasPrevious() || false,
  hasNext: infiniteScrollInstance?.dataManager.hasNext() || false
};
$: exposedPrevious = {
  loading: loadingPrevious,
  fetch: fetchPrevious,
  autoMode: headerAutoMode,
  manualMode: !headerAutoMode,
  hasMore: infiniteScrollInstance?.dataManager.hasPrevious() || false,
  ...sharedExposed
};
$: exposedNext = {
  loading: loadingNext,
  fetch: fetchNext,
  autoMode: footerAutoMode,
  manualMode: !footerAutoMode,
  hasMore: infiniteScrollInstance?.dataManager.hasNext() || false,
  ...sharedExposed
};
$: exposedSlot = {
  loading: loadingPrevious || loadingNext,
  loadingPrevious,
  loadingNext
};
let infiniteScrollInstance = null;
function resolveHTMLElement(value, fallback) {
  if (!value) {
    return fallback;
  }
  if (typeof value === "string") {
    return document.querySelector(value);
  }
  if (typeof value === "function") {
    return value() || null;
  }
  return fallback;
}
function scrollToBottom() {
  if (scrollableParent) {
    scrollableParent.scrollTo({
      top: scrollableParent.scrollHeight,
      behavior: "instant"
    });
  } else {
    window.scrollTo({
      top: document.body.scrollHeight,
      behavior: "instant"
    });
  }
}
export function fetchPrevious(options) {
  infiniteScrollInstance?.dataManager.fetchPrevious(options);
}
export function fetchNext(options) {
  infiniteScrollInstance?.dataManager.fetchNext(options);
}
export function hasPrevious() {
  return infiniteScrollInstance?.dataManager.hasPrevious() || false;
}
export function hasNext() {
  return infiniteScrollInstance?.dataManager.hasNext() || false;
}
onMount(() => {
  setTimeout(setupInfiniteScrollInstance);
});
function setupInfiniteScrollInstance() {
  const resolvedItemsElement2 = resolveHTMLElement(itemsElement, itemsElementRef);
  const resolvedStartElement = resolveHTMLElement(startElement, startElementRef);
  const resolvedEndElement = resolveHTMLElement(endElement, endElementRef);
  infiniteScrollInstance = useInfiniteScroll({
    // Data
    getPropName: () => data,
    inReverseMode: () => reverse,
    shouldFetchNext: () => !onlyPrevious,
    shouldFetchPrevious: () => !onlyNext,
    shouldPreserveUrl: () => preserveUrl,
    // Elements
    getTriggerMargin: () => buffer,
    getStartElement: () => resolvedStartElement,
    getEndElement: () => resolvedEndElement,
    getItemsElement: () => resolvedItemsElement2,
    getScrollableParent: () => resolvedItemsElement2 ? getScrollableParent(resolvedItemsElement2) : null,
    // Request callbacks
    onBeforePreviousRequest: () => loadingPrevious = true,
    onBeforeNextRequest: () => loadingNext = true,
    onCompletePreviousRequest: () => {
      requestCount = infiniteScrollInstance.dataManager.getRequestCount();
      loadingPrevious = false;
    },
    onCompleteNextRequest: () => {
      requestCount = infiniteScrollInstance.dataManager.getRequestCount();
      loadingNext = false;
    }
  });
  const { dataManager, elementManager } = infiniteScrollInstance;
  requestCount = dataManager.getRequestCount();
  elementManager.setupObservers();
  elementManager.processServerLoadedElements(dataManager.getLastLoadedPage());
  const shouldAutoScroll = autoScroll !== void 0 ? autoScroll : reverse;
  if (shouldAutoScroll) {
    scrollToBottom();
  }
}
$: manualMode = manual || manualAfter > 0 && requestCount >= manualAfter;
$: autoLoad = !manualMode;
$: headerAutoMode = autoLoad && !onlyNext;
$: footerAutoMode = autoLoad && !onlyPrevious;
$: {
  ;
  [autoLoad, onlyNext, onlyPrevious, reverse];
  autoLoad ? infiniteScrollInstance?.elementManager.enableTriggers() : infiniteScrollInstance?.elementManager.disableTriggers();
}
onDestroy(() => infiniteScrollInstance?.flush());
</script>

{#if !startElement && !reverse}
  <div bind:this={startElementRef}>
    <slot name="previous" {exposedPrevious} {...exposedPrevious}>
      {#if loadingPrevious}
        <slot name="loading" {exposedPrevious} {...exposedPrevious} />
      {/if}
    </slot>
  </div>
{/if}

{#if !endElement && reverse}
  <div bind:this={endElementRef}>
    <slot name="next" {exposedNext} {...exposedNext}>
      {#if loadingNext}
        <slot name="loading" {exposedNext} {...exposedNext} />
      {/if}
    </slot>
  </div>
{/if}

<svelte:element this={as} bind:this={itemsElementRef} {...$$restProps}>
  <slot {exposedSlot} {...exposedSlot} />
</svelte:element>

{#if !startElement && reverse}
  <div bind:this={startElementRef}>
    <slot name="previous" {exposedPrevious} {...exposedPrevious}>
      {#if loadingPrevious}
        <slot name="loading" {exposedPrevious} {...exposedPrevious} />
      {/if}
    </slot>
  </div>
{/if}

{#if !endElement && !reverse}
  <div bind:this={endElementRef}>
    <slot name="next" {exposedNext} {...exposedNext}>
      {#if loadingNext}
        <slot name="loading" {exposedNext} {...exposedNext} />
      {/if}
    </slot>
  </div>
{/if}
